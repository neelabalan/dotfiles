#!/usr/bin/env python3

# original idea from https://github.com/mawoka-myblock/mubert
# ctrl+c and ctrl+z to exit

import http.cookiejar
import json
import os
import pathlib
import platform
import shutil
import subprocess
import sys
import tempfile
import threading
import time
import typing
import urllib.request

headers: dict[str, str] = {'User-Agent': 'MubertAndroid', 'Content-Type': 'application/json'}
payload: dict[str, typing.Any] = {
    'method': 'AppGetPages',
    'params': {'timestamp': 0},
    'application': 'Mubert',
    'language': 'en',
    'os': 'Android',
    'sandbox': False,
    'version': '4.2.0',
}

cookie_jar = http.cookiejar.CookieJar()
opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie_jar))


def init_cookies() -> None:
    request = urllib.request.Request('https://mubert.com', headers=headers)
    try:
        opener.open(request)
    except urllib.error.URLError as e:
        print(f'error: failed to connect to mubert.com: {e.reason}')
        sys.exit(1)


def get_streams() -> dict[str, typing.Any]:
    jsonpath = pathlib.Path(__file__).parent / 'mubert.json'
    if jsonpath.exists():
        with open(str(jsonpath), 'r') as file:
            cached: dict[str, typing.Any] = json.load(file)
            return cached

    data = json.dumps(payload).encode('utf-8')
    request = urllib.request.Request(
        'https://api-app.mubert.com/v2/AppGetPages',
        data=data,
        headers=headers,
        method='POST',
    )
    try:
        with opener.open(request) as response:
            fetched: dict[str, typing.Any] = json.load(response)
            return fetched
    except urllib.error.URLError as e:
        print(f'error: failed to fetch streams: {e.reason}')
        sys.exit(1)


def extract_url_names(response: dict[str, typing.Any]) -> dict[str, str]:
    data: dict[str, str] = {}
    pages: list[dict[str, typing.Any]] = response.get('data', {}).get('pages', [])
    for section in pages:
        for unit in section.get('units', []):
            streams = unit.get('streams')
            if streams:
                for stream in streams:
                    data[stream.get('title') or unit.get('name')] = stream.get('url')
    return data


def get_choice_of_stream(data: dict[str, str]) -> str | None:
    names = list(data.keys())
    print('available streams:')
    for idx, name in enumerate(names, 1):
        print(f'  {idx:2}. {name}')

    try:
        choice = input('select stream number (q to quit): ').strip()
        if choice.lower() == 'q':
            return None
        idx = int(choice) - 1
        if 0 <= idx < len(names):
            return names[idx]
        print('invalid selection')
        return None
    except ValueError:
        print('invalid input')
        return None


def find_player() -> list[str] | None:
    if shutil.which('mpv'):
        return ['mpv']
    if platform.system() == 'Darwin' and shutil.which('afplay'):
        return ['afplay']
    if shutil.which('ffplay'):
        return ['ffplay', '-nodisp', '-autoexit']
    if shutil.which('cvlc'):
        return ['cvlc', '--play-and-exit']
    return None


def download_stream(filename: str, url: str) -> None:
    request = urllib.request.Request(url, headers=headers)
    with opener.open(request) as response, open(filename, 'ab') as file:
        while chunk := response.read(8192):
            file.write(chunk)


def run() -> None:
    player = find_player()
    if not player:
        print('error: no audio player found (mpv, afplay, ffplay, or cvlc)')
        sys.exit(1)

    print(f'using player: {player[0]}')

    init_cookies()
    response = get_streams()
    data = extract_url_names(response)
    stream = get_choice_of_stream(data)

    if not stream:
        return

    print(f'streaming: {stream}')
    fd, filename = tempfile.mkstemp(suffix='.mp3')
    filepath = pathlib.Path(filename)
    os.close(fd)
    try:
        download = threading.Thread(target=download_stream, args=(filename, data.get(stream)), daemon=True)
        download.start()
        for _ in range(15):
            time.sleep(1)
            if filepath.stat().st_size > 128 * 1024:
                break
        if filepath.stat().st_size == 0:
            print('error: failed to download stream')
            sys.exit(1)
        subprocess.run(player + [filename])
    except (KeyboardInterrupt, SystemExit):
        pass
    finally:
        if filepath.exists():
            filepath.unlink()


if __name__ == '__main__':
    if sys.version_info < (3, 11):
        print('error: this script requires Python 3.11 or later')
        sys.exit(1)

    run()
