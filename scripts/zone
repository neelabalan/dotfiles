#!/usr/bin/env python3

# original idea from https://github.com/mawoka-myblock/mubert
# ctrl+c and ctrl+z to exit

import argparse
import http.cookiejar
import json
import os
import pathlib
import platform
import random
import shutil
import subprocess
import sys
import tempfile
import threading
import time
import typing
import urllib.request
import uuid

headers: dict[str, str] = {'User-Agent': 'MubertAndroid', 'Content-Type': 'application/json'}
payload: dict[str, typing.Any] = {
    'method': 'AppGetPages',
    'params': {'timestamp': 0},
    'application': 'Mubert',
    'language': 'en',
    'os': 'Android',
    'sandbox': False,
    'version': '4.2.0',
}

cookie_jar = http.cookiejar.CookieJar()
opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie_jar))


def generate_mat_cookies() -> None:
    mat_id = str(int(time.time() * 1000000) % 10000000000000000)
    mat = f'{uuid.uuid4().hex[:30]}.{int(time.time())}'

    def make_cookie(name: str, value: str) -> http.cookiejar.Cookie:
        return http.cookiejar.Cookie(
            version=0,
            name=name,
            value=value,
            port=None,
            port_specified=False,
            domain='.mubert.com',
            domain_specified=True,
            domain_initial_dot=True,
            path='/',
            path_specified=True,
            secure=False,
            expires=None,
            discard=True,
            comment=None,
            comment_url=None,
            rest={},
        )

    cookie_jar.set_cookie(make_cookie('mat', mat))
    cookie_jar.set_cookie(make_cookie('mat_id', mat_id))


def init_cookies() -> None:
    request = urllib.request.Request('https://mubert.com', headers=headers)
    try:
        opener.open(request)
        generate_mat_cookies()
    except urllib.error.URLError as e:
        print(f'error: failed to connect to mubert.com: {e.reason}')
        sys.exit(1)


def get_streams() -> dict[str, typing.Any]:
    cache_dir = pathlib.Path.home() / '.dotfiles' / '.cache'
    cache_dir.mkdir(parents=True, exist_ok=True)
    cache_file = cache_dir / 'mubert.json'

    if cache_file.exists():
        with open(cache_file, 'r') as file:
            cached: dict[str, typing.Any] = json.load(file)
            return cached

    data = json.dumps(payload).encode('utf-8')
    request = urllib.request.Request(
        'https://api-app.mubert.com/v2/AppGetPages',
        data=data,
        headers=headers,
        method='POST',
    )
    try:
        with opener.open(request) as response:
            fetched: dict[str, typing.Any] = json.load(response)
            with open(cache_file, 'w') as file:
                json.dump(fetched, file, indent=2)
            return fetched
    except urllib.error.URLError as e:
        print(f'error: failed to fetch streams: {e.reason}')
        sys.exit(1)


def extract_url_names(response: dict[str, typing.Any]) -> dict[str, str]:
    data: dict[str, str] = {}
    pages: list[dict[str, typing.Any]] = response.get('data', {}).get('pages', [])
    for section in pages:
        for unit in section.get('units', []):
            streams = unit.get('streams')
            if streams:
                for stream in streams:
                    data[stream.get('title') or unit.get('name')] = stream.get('url')
    return data


def get_choice_of_stream(data: dict[str, str], stream_number: int | None = None) -> str | None:
    names = list(data.keys())

    if stream_number is not None:
        idx = stream_number - 1
        if 0 <= idx < len(names):
            return names[idx]
        print(f'error: invalid stream number {stream_number} (valid range: 1-{len(names)})')
        return None

    print('available streams:')
    for idx, name in enumerate(names, 1):
        print(f'  {idx:2}. {name}')

    try:
        choice = input('select stream number (q to quit): ').strip()
        if choice.lower() == 'q':
            return None
        idx = int(choice) - 1
        if 0 <= idx < len(names):
            return names[idx]
        print('invalid selection')
        return None
    except ValueError:
        print('invalid input')
        return None


def find_player() -> list[str] | None:
    if shutil.which('mpv'):
        return ['mpv']
    if platform.system() == 'Darwin' and shutil.which('afplay'):
        return ['afplay']
    if shutil.which('ffplay'):
        return ['ffplay', '-nodisp', '-autoexit']
    if shutil.which('cvlc'):
        return ['cvlc', '--play-and-exit']
    return None


def download_stream(filename: str, url: str) -> None:
    request = urllib.request.Request(url, headers=headers)
    with opener.open(request) as response, open(filename, 'ab') as file:
        while chunk := response.read(8192):
            file.write(chunk)


def play_stream(player: list[str], stream_name: str, stream_url: str, duration: int | None = None) -> bool:
    fd, filename = tempfile.mkstemp(suffix='.mp3')
    filepath = pathlib.Path(filename)
    os.close(fd)

    try:
        download = threading.Thread(target=download_stream, args=(filename, stream_url), daemon=True)
        download.start()

        for _ in range(15):
            time.sleep(1)
            if filepath.stat().st_size > 128 * 1024:
                break

        if filepath.stat().st_size == 0:
            print('error: failed to download stream')
            return False

        if duration:
            process = subprocess.Popen(player + [filename])
            time.sleep(duration * 60)
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
        else:
            subprocess.run(player + [filename])

        return True

    finally:
        if filepath.exists():
            filepath.unlink()


def run(stream_number: int | None = None, shuffle_minutes: int | None = None) -> None:
    player = find_player()
    if not player:
        print('error: no audio player found (mpv, afplay, ffplay, or cvlc)')
        sys.exit(1)

    print(f'using player: {player[0]}')

    init_cookies()
    response = get_streams()
    data = extract_url_names(response)
    stream_names = list(data.keys())

    if shuffle_minutes:
        print(f'shuffle mode: changing stream every {shuffle_minutes} minute(s)')

        try:
            while True:
                stream = random.choice(stream_names)
                stream_idx = stream_names.index(stream) + 1
                print(f'[{stream_idx}/{len(stream_names)}] streaming: {stream}')
                if not play_stream(player, stream, data[stream], shuffle_minutes):
                    continue
        except (KeyboardInterrupt, SystemExit):
            pass
    else:
        stream = get_choice_of_stream(data, stream_number)
        if not stream:
            return

        stream_idx = stream_names.index(stream) + 1
        print(f'[{stream_idx}/{len(stream_names)}] streaming: {stream}')
        try:
            play_stream(player, stream, data[stream])
        except (KeyboardInterrupt, SystemExit):
            pass


if __name__ == '__main__':
    if sys.version_info < (3, 11):
        print('error: this script requires Python 3.11 or later')
        sys.exit(1)

    parser = argparse.ArgumentParser(description='Stream music from Mubert')
    parser.add_argument(
        '--stream',
        type=int,
        metavar='N',
        help='stream number to play (bypasses interactive selection)',
    )
    parser.add_argument(
        '--shuffle',
        type=int,
        metavar='MINUTES',
        help='randomly shuffle streams every N minutes',
    )
    args = parser.parse_args()

    run(args.stream, args.shuffle)
