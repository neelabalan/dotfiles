#!/usr/bin/env python3

import abc
import argparse
import dataclasses
import json
import os
import pathlib
import shutil
import string
import subprocess
import sys
import textwrap
import typing
import urllib.request


@dataclasses.dataclass
class DirConfig:
    source_template: str = ''
    test_template: str | None = None
    is_default: bool = False
    subdirs: dict[str, 'DirConfig'] = dataclasses.field(default_factory=dict)


@dataclasses.dataclass
class HandlerConfig:
    language: str
    workspace_root: pathlib.Path
    dirs: dict[str, DirConfig]
    warn: bool = True
    editor: str = 'code'


class ExecutionMode:
    TEST = 'test'
    RUN = 'run'


class Config:
    CONFIG_PATH = pathlib.Path.home() / '.dotfiles' / '.px.json'

    DEFAULT_DIR = 'misc'
    SOURCE_TEMPLATE = 'source_template'
    TEST_TEMPLATE = 'test_template'
    DEFAULT = 'default'

    def __init__(self) -> None:
        self.config = self._load_config()
        self.workspace_root = pathlib.Path(self.config.get('workspace_root', '.'))
        self.editor = self.config.get('editor', 'code')
        self.warn = os.getenv('WARN', '1') == '1'

    def _load_config(self) -> dict[str, typing.Any]:
        if self.CONFIG_PATH.exists():
            return json.loads(self.CONFIG_PATH.read_text())  # type: ignore[no-any-return]

        return {
            'workspace_root': str(pathlib.Path.home() / 'code/experiments'),
            'editor': 'code',
            'workspace': [
                {'language': 'python', 'dirs': {'pylang': {'misc': {'default': True}}}},
                {'language': 'rust', 'dirs': {'rustlang': {'misc': {'default': True}}}},
                {'language': 'go', 'dirs': {'golang': {'misc': {'default': True}}}},
            ],
        }

    def _make_template_dict(self, current: dict[str, typing.Any]) -> dict[str, str | None]:
        return {
            Config.SOURCE_TEMPLATE: current.get(Config.SOURCE_TEMPLATE, ''),
            Config.TEST_TEMPLATE: current.get(Config.TEST_TEMPLATE),
        }

    def validate_config(self, valid_languages: set[str]) -> None:
        workspace_entries = self.config.get('workspace', [])

        default_counts: dict[str, int] = {}

        for idx, entry in enumerate(workspace_entries):
            language = entry.get('language')

            if not language:
                raise ValueError(f"workspace entry {idx} missing 'language' field")

            if language not in valid_languages:
                raise ValueError(
                    f"unknown language '{language}' in workspace entry {idx}. "
                    f'valid languages: {", ".join(sorted(valid_languages))}'
                )

            dirs_config = entry.get('dirs', {})
            if not dirs_config:
                raise ValueError(f"workspace entry {idx} ({language}) has no 'dirs' defined")

            self._check_defaults_in_dirs(dirs_config, language, default_counts)

        for language, count in default_counts.items():
            if count > 1:
                raise ValueError(
                    f"language '{language}' has {count} directories marked as default. "
                    f'only one default directory allowed per language'
                )

    def _check_defaults_in_dirs(
        self,
        dirs_config: dict[str, typing.Any],
        language: str,
        default_counts: dict[str, int],
        path_parts: list[str] | None = None,
    ) -> None:
        if path_parts is None:
            path_parts = []

        for key, value in dirs_config.items():
            if not isinstance(value, dict):
                continue

            current_path = path_parts + [key]

            if value.get(Config.DEFAULT) is True:
                default_counts[language] = default_counts.get(language, 0) + 1

            nested_dirs = {
                k: v for k, v in value.items() if k not in (Config.DEFAULT, Config.SOURCE_TEMPLATE, Config.TEST_TEMPLATE)
            }
            if nested_dirs:
                self._check_defaults_in_dirs(nested_dirs, language, default_counts, current_path)

    def get_template_for_path(self, language: str, relative_path: pathlib.Path) -> dict[str, str | None] | None:
        for part in relative_path.parts:
            if part and part[0].isdigit():
                raise ValueError(f"directory names cannot start with digits: '{part}'")

        workspace_entries = self.config.get('workspace', [])

        for entry in workspace_entries:
            if entry.get('language') != language:
                continue

            dirs_config = entry.get('dirs', {})

            for base_dir, dir_structure in dirs_config.items():
                if not relative_path.parts or relative_path.parts[0] != base_dir:
                    continue

                remaining_parts = list(relative_path.parts[1:])
                current = dir_structure

                for part in remaining_parts:
                    if part in current:
                        current = current[part]
                    elif Config.SOURCE_TEMPLATE in current or Config.DEFAULT in current:
                        return self._make_template_dict(current)
                    else:
                        break

                if Config.SOURCE_TEMPLATE in current or Config.DEFAULT in current:
                    return self._make_template_dict(current)

        return None

    def get_all_directories(self) -> dict[str, list[pathlib.Path]]:
        result: dict[str, list[pathlib.Path]] = {}
        workspace_entries = self.config.get('workspace', [])

        for entry in workspace_entries:
            language = entry.get('language')
            if not language:
                continue

            if language not in result:
                result[language] = []

            dirs_config = entry.get('dirs', {})

            for base_dir, dir_structure in dirs_config.items():
                base_path = self.workspace_root / base_dir
                result[language].append(base_path)
                self._collect_dirs(dir_structure, base_path, result, language)
        return result

    def _collect_dirs(
        self,
        dir_config: dict[str, typing.Any],
        prefix: pathlib.Path,
        result: dict[str, list[pathlib.Path]],
        language: str,
    ) -> dict[str, list[pathlib.Path]]:
        for key, value in dir_config.items():
            if key in (Config.DEFAULT, Config.SOURCE_TEMPLATE, Config.TEST_TEMPLATE):
                continue
            if isinstance(value, dict):
                full_path = prefix / key
                result[language].append(full_path)
                self._collect_dirs(value, full_path, result, language)

        return result


def download_gitignore(language: str, target_path: pathlib.Path) -> bool:
    gitignore_urls = {
        'python': 'https://raw.githubusercontent.com/github/gitignore/main/Python.gitignore',
        'rust': 'https://raw.githubusercontent.com/github/gitignore/main/Rust.gitignore',
        'go': 'https://raw.githubusercontent.com/github/gitignore/main/Go.gitignore',
    }

    url = gitignore_urls.get(language)
    if not url:
        return False

    try:
        with urllib.request.urlopen(url) as response:
            content = response.read().decode('utf-8')
            target_path.write_text(content)
            print(f'created: {target_path}')
            return True
    except Exception as e:
        print(f'warning: failed to download .gitignore for {language}: {e}', file=sys.stderr)
        return False


class LanguageHandler(abc.ABC):
    EXTENSION: str

    def __init__(self, config: HandlerConfig) -> None:
        self.config = config

    @abc.abstractmethod
    def detect(self, path: pathlib.Path) -> bool:
        pass

    @abc.abstractmethod
    def execute(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        pass

    @abc.abstractmethod
    def create_files(self, path: pathlib.Path, source_template: str, test_template: str | None) -> None:
        pass

    @abc.abstractmethod
    def init_project(self, base_path: pathlib.Path) -> None:
        pass

    @abc.abstractmethod
    def find_project_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        pass

    @abc.abstractmethod
    def check(self, path: pathlib.Path) -> subprocess.CompletedProcess[bytes]:
        pass


class PythonHandler(LanguageHandler):
    EXTENSION = '.py'

    def detect(self, path: pathlib.Path) -> bool:
        if path.is_file():
            return path.suffix == '.py'
        return (path / 'pyproject.toml').exists() or any(path.glob('*.py'))

    def execute(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        if mode == ExecutionMode.TEST:
            args = ['uv', 'run', 'pytest', '-v', str(path)]
            if not self.config.warn:
                args.insert(3, '--disable-warnings')
            return subprocess.run(args, capture_output=False)
        else:
            return self._run_script(path)

    def create_files(self, path: pathlib.Path, source_template: str, test_template: str | None) -> None:
        source_path = path.with_suffix(self.EXTENSION)
        source_path.parent.mkdir(parents=True, exist_ok=True)
        source_path.write_text(source_template)
        print(f'created: {source_path}')

        if test_template:
            test_path = path.parent / f'{path.stem}_test{self.EXTENSION}'
            test_path.write_text(test_template)
            print(f'created: {test_path}')

    def init_project(self, base_path: pathlib.Path) -> None:
        pyproject_path = base_path / 'pyproject.toml'
        if not pyproject_path.exists():
            result = subprocess.run(
                ['uv', 'init', '--lib', '--no-readme', '--python', '3.11'], cwd=base_path, capture_output=True
            )
            if result.returncode != 0:
                raise RuntimeError(f'failed to initialize uv project: {result.stderr.decode()}')
            print(f'initialized uv project: {base_path}')

            pyproject_content = pyproject_path.read_text()
            pytest_config = textwrap.dedent("""
                [tool.pytest.ini_options]
                python_files = "*.py"
            """).rstrip()
            pyproject_path.write_text(pyproject_content + pytest_config)

            src_dir = base_path / 'src'
            if src_dir.exists():
                shutil.rmtree(src_dir)

        gitignore_path = base_path / '.gitignore'
        if not gitignore_path.exists():
            download_gitignore('python', gitignore_path)

        ruff_path = base_path / '.ruff.toml'
        if not ruff_path.exists():
            ruff_content = textwrap.dedent("""
                fix = true
                line-length = 121

                [lint]
                select = ["F", "W", "I001"]
                fixable = ["I001", "F401"]

                [format]
                # Prefer single quotes over double quotes.
                quote-style = "single"

                [lint.isort]
                force-single-line = true
            """).strip()
            ruff_path.write_text(ruff_content)
            print(f'created: {ruff_path}')

    def _run_script(self, path: pathlib.Path) -> subprocess.CompletedProcess[bytes]:
        if not path.is_file():
            raise ValueError(f'{path} is not a file')

        return subprocess.run(['uv', 'run', 'python', str(path)], capture_output=False)

    def find_project_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        current = file_path.parent if file_path.is_file() else file_path
        depth = 0
        max_depth = 50
        while current != current.parent and depth < max_depth:
            if (current / 'pyproject.toml').exists():
                return current
            current = current.parent
            depth += 1
        return None

    def check(self, path: pathlib.Path) -> subprocess.CompletedProcess[bytes]:
        import py_compile

        if path.is_file():
            try:
                py_compile.compile(str(path), doraise=True)
                print(f'ok: {path}')
                return subprocess.CompletedProcess(args=[], returncode=0, stdout=b'', stderr=b'')
            except py_compile.PyCompileError as e:
                if self.config.warn:
                    print(f'fail: {path}: {e}', file=sys.stderr)
                return subprocess.CompletedProcess(args=[], returncode=1, stdout=b'', stderr=str(e).encode())
        else:
            project_root = self.find_project_root(path)
            if project_root:
                return subprocess.run(['uv', 'run', 'ruff', 'check', str(path)], capture_output=False)
            else:
                print(f'error: {path} is not a file or project', file=sys.stderr)
                return subprocess.CompletedProcess(args=[], returncode=1, stdout=b'', stderr=b'')


class RustHandler(LanguageHandler):
    EXTENSION = '.rs'

    def detect(self, path: pathlib.Path) -> bool:
        if path.is_file():
            return path.suffix == '.rs'
        return (path / 'Cargo.toml').exists()

    def execute(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        env = os.environ.copy()
        if not self.config.warn:
            env['RUSTFLAGS'] = env.get('RUSTFLAGS', '') + ' -A warnings'

        if path.is_file():
            return self._run_single_file(path, mode, env)
        else:
            return self._run_cargo_project(path, mode, env)

    def _run_single_file(
        self, path: pathlib.Path, mode: str, env: dict | None = None
    ) -> subprocess.CompletedProcess[bytes]:
        cargo_root = self._find_cargo_root(path)

        if not cargo_root:
            raise ValueError(f'no Cargo.toml found for {path}. please create a Cargo project in the rust/ directory.')

        if mode == ExecutionMode.TEST:
            module_path = self._get_module_path(path, cargo_root)
            return subprocess.run(
                ['cargo', 'test', '--lib', module_path, '--', '--nocapture'],
                cwd=cargo_root,
                capture_output=False,
                env=env,
            )
        else:
            raise NotImplementedError('run mode not supported for single Rust files')

    def _run_cargo_project(
        self, path: pathlib.Path, mode: str, env: dict | None = None
    ) -> subprocess.CompletedProcess[bytes]:
        if mode == ExecutionMode.TEST:
            return subprocess.run(['cargo', 'test', '--', '--nocapture'], cwd=path, capture_output=False, env=env)
        else:
            return subprocess.run(['cargo', 'run'], cwd=path, capture_output=False, env=env)

    def _find_cargo_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        current = file_path.parent
        depth = 0
        max_depth = 50
        while current != current.parent and depth < max_depth:
            if (current / 'Cargo.toml').exists():
                return current
            current = current.parent
            depth += 1
        return None

    def _get_module_path(self, file_path: pathlib.Path, cargo_root: pathlib.Path) -> str:
        relative = file_path.relative_to(cargo_root)
        parts = list(relative.parts)

        if parts[0] == 'src':
            parts = parts[1:]

        if parts[-1].endswith('.rs'):
            parts[-1] = parts[-1][:-3]

        return '::'.join(parts)

    def create_files(self, path: pathlib.Path, source_template: str, test_template: str | None) -> None:
        source_path = path.with_suffix(self.EXTENSION)
        source_path.parent.mkdir(parents=True, exist_ok=True)
        source_path.write_text(source_template)
        print(f'created: {source_path}')

        self._update_rust_lib(source_path)

        if test_template:
            test_path = path.parent / f'{path.stem}_test{self.EXTENSION}'
            test_path.write_text(test_template)
            print(f'created: {test_path}')

    def init_project(self, base_path: pathlib.Path) -> None:
        cargo_path = base_path / 'Cargo.toml'

        if cargo_path.exists():
            print(f'cargo.toml already exists at {cargo_path}')
        else:
            lib_name = base_path.name.replace('-', '_')
            result = subprocess.run(['cargo', 'init', '--lib', '--name', lib_name], cwd=base_path, capture_output=True)
            if result.returncode != 0:
                raise RuntimeError(f'failed to initialize cargo project: {result.stderr.decode()}')
            print(f'initialized cargo project: {base_path}')

            cargo_content = cargo_path.read_text()
            lib_config = '\n[lib]\npath = "lib.rs"\n'
            cargo_path.write_text(cargo_content.rstrip() + lib_config)

            src_dir = base_path / 'src'
            if src_dir.exists():
                shutil.rmtree(src_dir)

            lib_path = base_path / 'lib.rs'
            if not lib_path.exists():
                lib_path.write_text('')
                print(f'created: {lib_path}')

        gitignore_path = base_path / '.gitignore'
        if not gitignore_path.exists():
            download_gitignore('rust', gitignore_path)

    def _update_rust_lib(self, rust_file: pathlib.Path) -> None:
        cargo_root = self._find_cargo_root(rust_file)
        if not cargo_root:
            return

        lib_path = cargo_root / 'lib.rs'
        if not lib_path.exists():
            return

        relative_path = rust_file.relative_to(cargo_root)
        dir_parts = list(relative_path.parts[:-1])
        module_name = rust_file.stem

        if not dir_parts:
            self._add_module_declaration(lib_path, module_name)
            return

        self._add_module_declaration(lib_path, dir_parts[0])

        current_path = cargo_root
        for i, part in enumerate(dir_parts):
            current_path = current_path / part
            current_path.mkdir(exist_ok=True)

            mod_file = current_path / 'mod.rs'

            if i < len(dir_parts) - 1:
                next_part = dir_parts[i + 1]
                self._add_module_declaration(mod_file, next_part)
            else:
                self._add_module_declaration(mod_file, module_name)

    def _add_module_declaration(self, mod_file: pathlib.Path, module_name: str) -> None:
        declaration = f'pub mod {module_name};\n'

        if mod_file.exists():
            content = mod_file.read_text()
            if f'mod {module_name};' not in content:
                content += declaration
                mod_file.write_text(content)
        else:
            mod_file.write_text(declaration)

    def find_project_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        return self._find_cargo_root(file_path)

    def check(self, path: pathlib.Path) -> subprocess.CompletedProcess[bytes]:
        cargo_root = self._find_cargo_root(path) if path.is_file() else path
        if not cargo_root:
            print(f'error: no Cargo.toml found for {path}', file=sys.stderr)
            return subprocess.CompletedProcess(args=[], returncode=1, stdout=b'', stderr=b'')

        env = os.environ.copy()
        if not self.config.warn:
            env['RUSTFLAGS'] = env.get('RUSTFLAGS', '') + ' -A warnings'

        return subprocess.run(['cargo', 'check'], cwd=cargo_root, capture_output=False, env=env)


class GoHandler(LanguageHandler):
    EXTENSION = '.go'

    def detect(self, path: pathlib.Path) -> bool:
        if path.is_file():
            return path.suffix == '.go'
        return (path / 'go.mod').exists()

    def execute(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        if path.is_file():
            return self._run_single_file(path, mode)
        else:
            return self._run_go_module(path, mode)

    def _run_single_file(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        go_mod_root = self._find_go_mod_root(path)

        if mode == ExecutionMode.TEST:
            if go_mod_root:
                package_path = self._get_package_path(path, go_mod_root)
                return subprocess.run(['go', 'test', '-v', package_path], cwd=go_mod_root, capture_output=False)
            else:
                test_file = path.parent / f'{path.stem}_test.go'
                if test_file.exists():
                    return subprocess.run(['go', 'test', '-v', str(path), str(test_file)], capture_output=False)
                else:
                    return subprocess.run(['go', 'test', '-v', str(path)], capture_output=False)
        else:
            return subprocess.run(['go', 'run', str(path)], capture_output=False)

    def _run_go_module(self, path: pathlib.Path, mode: str) -> subprocess.CompletedProcess[bytes]:
        if mode == ExecutionMode.TEST:
            return subprocess.run(['go', 'test', '-v', './...'], cwd=path, capture_output=False)
        else:
            return subprocess.run(['go', 'run', '.'], cwd=path, capture_output=False)

    def _find_go_mod_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        current = file_path.parent
        depth = 0
        max_depth = 50
        while current != current.parent and depth < max_depth:
            if (current / 'go.mod').exists():
                return current
            current = current.parent
            depth += 1
        return None

    def _get_package_path(self, file_path: pathlib.Path, go_mod_root: pathlib.Path) -> str:
        relative = file_path.parent.relative_to(go_mod_root)
        return f'./{relative}'

    def create_files(self, path: pathlib.Path, source_template: str, test_template: str | None) -> None:
        source_path = path.with_suffix(self.EXTENSION)
        source_path.parent.mkdir(parents=True, exist_ok=True)

        package_name = source_path.parent.name
        source_content = string.Template(source_template).safe_substitute(package_name=package_name)
        source_path.write_text(source_content)
        print(f'created: {source_path}')

        if test_template:
            test_path = path.parent / f'{path.stem}_test{self.EXTENSION}'
            test_content = string.Template(test_template).safe_substitute(package_name=package_name)
            test_path.write_text(test_content)
            print(f'created: {test_path}')

    def init_project(self, base_path: pathlib.Path) -> None:
        go_mod_path = base_path / 'go.mod'

        if go_mod_path.exists():
            print(f'go.mod already exists at {go_mod_path}')
        else:
            module_name = base_path.name
            result = subprocess.run(['go', 'mod', 'init', module_name], cwd=base_path, capture_output=True)
            if result.returncode != 0:
                raise RuntimeError(f'failed to initialize go module: {result.stderr.decode()}')
            print(f'initialized go module: {base_path}')

        gitignore_path = base_path / '.gitignore'
        if not gitignore_path.exists():
            download_gitignore('go', gitignore_path)

    def find_project_root(self, file_path: pathlib.Path) -> typing.Optional[pathlib.Path]:
        return self._find_go_mod_root(file_path)

    def check(self, path: pathlib.Path) -> subprocess.CompletedProcess[bytes]:
        go_mod_root = self._find_go_mod_root(path) if path.is_file() else path
        if go_mod_root:
            return subprocess.run(['go', 'vet', './...'], cwd=go_mod_root, capture_output=False)
        else:
            if path.is_file():
                return subprocess.run(['go', 'vet', str(path)], capture_output=False)
            else:
                print(f'error: no go.mod found for {path}', file=sys.stderr)
                return subprocess.CompletedProcess(args=[], returncode=1, stdout=b'', stderr=b'')


HANDLER_CLASSES: dict[str, type[LanguageHandler]] = {
    'python': PythonHandler,
    'rust': RustHandler,
    'go': GoHandler,
}


def build_handlers(config: Config) -> dict[str, LanguageHandler]:
    handlers = {}
    workspace_entries = config.config.get('workspace', [])

    for entry in workspace_entries:
        language = entry.get('language')
        if not language or language not in HANDLER_CLASSES:
            continue

        dirs_config = entry.get('dirs', {})
        parsed_dirs = _parse_dir_config(dirs_config)

        handler_config = HandlerConfig(
            language=language,
            workspace_root=config.workspace_root,
            dirs=parsed_dirs,
            warn=config.warn,
            editor=config.editor,
        )

        handler_class = HANDLER_CLASSES[language]
        handlers[language] = handler_class(handler_config)

    return handlers


def _parse_dir_config(dirs: dict[str, typing.Any]) -> dict[str, DirConfig]:
    result = {}

    for key, value in dirs.items():
        if not isinstance(value, dict):
            continue

        source_template = value.get(Config.SOURCE_TEMPLATE, '')
        test_template = value.get(Config.TEST_TEMPLATE)
        is_default = value.get(Config.DEFAULT, False)

        subdirs = {
            k: v for k, v in value.items() if k not in (Config.DEFAULT, Config.SOURCE_TEMPLATE, Config.TEST_TEMPLATE)
        }
        parsed_subdirs = _parse_dir_config(subdirs) if subdirs else {}

        result[key] = DirConfig(
            source_template=source_template,
            test_template=test_template,
            is_default=is_default,
            subdirs=parsed_subdirs,
        )

    return result


def detect_handler(path: pathlib.Path, handlers: dict[str, LanguageHandler]) -> typing.Optional[LanguageHandler]:
    for handler in handlers.values():
        if handler.detect(path):
            return handler
    return None


def run_command(path: pathlib.Path, handlers: dict[str, LanguageHandler], mode: str = ExecutionMode.TEST) -> int:
    input_path = pathlib.Path(path)
    full_path = input_path if input_path.is_absolute() else pathlib.Path.cwd() / input_path

    if not full_path.exists():
        print(f'error: {full_path} does not exist', file=sys.stderr)
        return 1

    handler = detect_handler(full_path, handlers)
    if not handler:
        print(f'error: could not detect language for {full_path}', file=sys.stderr)
        return 1

    try:
        result = handler.execute(full_path, mode)
        return result.returncode
    except Exception as e:
        print(f'error executing: {e}', file=sys.stderr)
        return 1


def check_command(path: pathlib.Path, handlers: dict[str, LanguageHandler]) -> int:
    input_path = pathlib.Path(path)
    full_path = input_path if input_path.is_absolute() else pathlib.Path.cwd() / input_path

    if not full_path.exists():
        print(f'error: {full_path} does not exist', file=sys.stderr)
        return 1

    handler = detect_handler(full_path, handlers)
    if not handler:
        print(f'error: could not detect language for {full_path}', file=sys.stderr)
        return 1

    try:
        result = handler.check(full_path)
        return result.returncode
    except Exception as e:
        print(f'error checking: {e}', file=sys.stderr)
        return 1


def ls_command(config: Config) -> int:
    try:
        print(config.workspace_root)

        all_dirs = config.get_all_directories()

        all_paths = set()
        for dirs in all_dirs.values():
            for dir_path in dirs:
                if dir_path.exists():
                    all_paths.add(dir_path)

        for path in sorted(all_paths):
            print(path)

        return 0
    except Exception as e:
        print(f'error listing directories: {e}', file=sys.stderr)
        return 1


def init_directories(config: Config, handlers: dict[str, LanguageHandler]) -> int:
    try:
        if not config.CONFIG_PATH.exists():
            config.CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
            config.CONFIG_PATH.write_text(json.dumps(config.config, indent=2))
            print(f'created config: {config.CONFIG_PATH}')

        all_dirs = config.get_all_directories()
        workspace_entries = config.config.get('workspace', [])
        initialized_projects = {}

        for language, dirs in all_dirs.items():
            for dir_path in dirs:
                dir_path.mkdir(parents=True, exist_ok=True)
                print(f'created: {dir_path}')

            handler = handlers.get(language)
            if not handler:
                continue

            for entry in workspace_entries:
                if entry.get('language') != language:
                    continue

                for base_dir in entry.get('dirs', {}).keys():
                    project_key = (language, base_dir)
                    if project_key in initialized_projects:
                        continue

                    base_path = config.workspace_root / base_dir
                    handler.init_project(base_path)
                    initialized_projects[project_key] = True

        return 0
    except Exception as e:
        print(f'error initializing directories: {e}', file=sys.stderr)
        return 1


def create_file(config: Config, handlers: dict[str, LanguageHandler], file_arg: str) -> int:
    try:
        input_path = pathlib.Path(file_arg)
        full_path = input_path if input_path.is_absolute() else pathlib.Path.cwd() / input_path

        if full_path.stem and full_path.stem[0].isdigit():
            print(f"error: filename cannot start with a digit: '{full_path.name}'", file=sys.stderr)
            return 1

        for lang, handler in handlers.items():
            if full_path.suffix == handler.EXTENSION:
                language = lang
                break
        else:
            supported = ', '.join(h.EXTENSION for h in handlers.values())
            print(f'error: unsupported file extension {full_path.suffix}. Supported: {supported}', file=sys.stderr)
            return 1

        relative_path = full_path.relative_to(config.workspace_root)

        handler = handlers[language]

        if not full_path.exists():
            template = config.get_template_for_path(language, relative_path.parent)
            if template is None:
                print(f'error: no configuration found for path {relative_path.parent}', file=sys.stderr)
                return 1

            source_template = template.get(Config.SOURCE_TEMPLATE) or ''
            test_template = template.get(Config.TEST_TEMPLATE)
            handler.create_files(full_path.with_suffix(''), source_template, test_template)
        else:
            print(f'file already exists: {full_path}')

        project_root = handler.find_project_root(full_path)
        if project_root:
            subprocess.run([config.editor, str(project_root), str(full_path)])
        else:
            subprocess.run([config.editor, str(config.workspace_root), str(full_path)])
        return 0

    except ValueError as e:
        print(f'error: {e}', file=sys.stderr)
        return 1
    except Exception as e:
        print(f'error creating file: {e}', file=sys.stderr)
        return 1


def open_folder(config: Config, handlers: dict[str, LanguageHandler], language: typing.Optional[str] = None) -> int:
    try:
        if language:
            if language not in handlers:
                supported = ', '.join(handlers.keys())
                print(f'error: unsupported language {language}. Supported: {supported}', file=sys.stderr)
                return 1
            folder_path = config.workspace_root / language
        else:
            folder_path = config.workspace_root

        if not folder_path.exists():
            print(f'error: folder does not exist: {folder_path}', file=sys.stderr)
            return 1

        subprocess.run([config.editor, str(folder_path)])
        return 0

    except Exception as e:
        print(f'error opening folder: {e}', file=sys.stderr)
        return 1


def main() -> None:
    parser = argparse.ArgumentParser(
        description='Unified project runner and scaffolding tool for multiple languages',
        epilog="""
Commands:
  init      Initialize workspace directory structure from config file
  validate  Validate the configuration file for errors
  new       Create a new file from template
  check     Check syntax without compilation (cargo check, go vet, py_compile)
  test      Run tests for a file or project
  run       Execute a file or project
  ls        List all workspace directories
  open      Open workspace or language folder in configured editor

Supported Languages:
  python    Uses uv for project management and pytest for testing
  rust      Uses cargo for project management and testing
  go        Uses go modules for project management and testing

Configuration:
  Config file location: ~/.dotfiles/.px.json
  The config defines workspace structure, templates, and default directories
  for each language. Each language can have multiple directories with custom
  source and test templates.

Shell Integration (for cd command):
  Add this function to your ~/.bashrc or ~/.zshrc:
    pxcd() { cd "$(px ls | fzf)"; }

  Then use: pxcd (opens fzf to select directory)

Examples:
  %(prog)s init                                    Initialize workspace from config
  %(prog)s validate                                Validate config file
  %(prog)s new python/leetcode/solution.py        Create Python file from template
  %(prog)s new rust/misc/problem.rs               Create Rust file from template
  %(prog)s check python/solution.py               Check Python file syntax
  %(prog)s check rust/problem.rs                  Run cargo check
  %(prog)s ls                                     List all workspace directories
  %(prog)s test python/solution.py                Run tests for Python file
  %(prog)s test rust/problem.rs                   Run tests for Rust file
  %(prog)s run python/script.py                   Execute Python script
  %(prog)s run go/main.go                         Execute Go file
  %(prog)s open                                   Open workspace root in editor
  %(prog)s open python                            Open Python folder in editor
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest='command', required=True, help='Commands')

    subparsers.add_parser('init', help='Initialize directory structure from config')
    subparsers.add_parser('validate', help='Validate configuration file')

    new_parser = subparsers.add_parser('new', help='Create a new file from template')
    new_parser.add_argument(
        'path', type=str, help='File path to create (e.g., rust/leetcode/p01.rs, leetcode/p01.rs, solution.py)'
    )

    check_parser = subparsers.add_parser('check', help='Check syntax without compilation')
    check_parser.add_argument('path', type=pathlib.Path, help='Path to file or project to check')

    subparsers.add_parser('ls', help='List all workspace directories')

    test_parser = subparsers.add_parser('test', help='Run tests for a file')
    test_parser.add_argument('path', type=pathlib.Path, help='Path to file to test')

    run_parser = subparsers.add_parser('run', help='Execute a file')
    run_parser.add_argument('path', type=pathlib.Path, help='Path to file to run')

    open_parser = subparsers.add_parser('open', help='Open workspace or language folder in editor')
    open_parser.add_argument('language', type=str, nargs='?', help='Language folder to open (e.g., python, rust, go)')

    args = parser.parse_args()

    config = Config()

    # Build handlers with their configurations
    handlers = build_handlers(config)

    if args.command == 'init':
        try:
            config.validate_config(set(HANDLER_CLASSES.keys()))
        except ValueError as e:
            print(f'config validation failed: {e}', file=sys.stderr)
            sys.exit(1)
        return_code = init_directories(config, handlers)
    elif args.command == 'validate':
        try:
            config.validate_config(set(HANDLER_CLASSES.keys()))
            return_code = 0
        except ValueError as e:
            print(f'config validation failed: {e}', file=sys.stderr)
            return_code = 1
    elif args.command == 'new':
        return_code = create_file(config, handlers, args.path)
    elif args.command == 'check':
        return_code = check_command(args.path, handlers)
    elif args.command == 'ls':
        return_code = ls_command(config)
    elif args.command == 'test':
        return_code = run_command(args.path, handlers, ExecutionMode.TEST)
    elif args.command == 'run':
        return_code = run_command(args.path, handlers, ExecutionMode.RUN)
    elif args.command == 'open':
        return_code = open_folder(config, handlers, args.language)
    else:
        parser.print_help()
        return_code = 0

    sys.exit(return_code)


if __name__ == '__main__':
    main()
